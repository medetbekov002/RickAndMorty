package com.london.rickandmorty.data.baseimport android.content.ContentValues.TAGimport android.net.Uriimport android.util.Logimport androidx.paging.PagingSourceimport androidx.paging.PagingStateimport com.london.rickandmorty.data.extensions.DataMapperimport retrofit2.HttpExceptionimport retrofit2.Responseimport java.io.IOExceptionprivate const val BASE_STARTING_PAGE_INDEX = 1abstract class BasePagingSource<ValueDto : DataMapper<Value>, Value : Any>(    private val request: suspend (position: Int) -> Response<BaseResponse<ValueDto>>) : PagingSource<Int, Value>() {    override suspend fun load(params: LoadParams<Int>): LoadResult<Int, Value> {        val position = params.key ?: BASE_STARTING_PAGE_INDEX        return try {            val response = request(position)            val data = response.body()!!            val nextPage = when (data.next) {                null -> null                else -> Uri.parse(data.next).getQueryParameter("page")?.toInt()            }            LoadResult.Page(                data = data.results.map { it.mapToDomain() },                prevKey = if (position==1) null else position -1,                nextKey = if (data.results.size == params.loadSize) position +(params.loadSize/position) else null            )                    }catch (e:IOException){            Log.e(TAG ,"OIException")            LoadResult.Error(e)        }catch (e:HttpException){            Log.e(TAG ,"HTTP EXCEPTION")            LoadResult.Error(e)        }    }    override fun getRefreshKey(state: PagingState<Int, Value>): Int? {        val anchorPos =state.anchorPosition?:return null        val page =state.closestPageToPosition(anchorPos)?:return null        return  page.prevKey?.plus(1) ?: page.nextKey?.minus(1)    }}